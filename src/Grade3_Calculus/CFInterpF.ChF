c*******************************************************************************
c  SOMAR - Stratified Ocean Model with Adaptive Refinement
c  Developed by Ed Santilli & Alberto Scotti
c  Copyright (C) 2019
c     Jefferson University and
c     University of North Carolina at Chapel Hill
c
c  This library is free software; you can redistribute it and/or
c  modify it under the terms of the GNU Lesser General Public
c  License as published by the Free Software Foundation; either
c  version 2.1 of the License, or (at your option) any later version.
c
c  This library is distributed in the hope that it will be useful,
c  but WITHOUT ANY WARRANTY; without even the implied warranty of
c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
c  Lesser General Public License for more details.
c
c  You should have received a copy of the GNU Lesser General Public
c  License along with this library; if not, write to the Free Software
c  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
c  USA
c
c  For up-to-date contact information, please visit the repository homepage,
c  https://github.com/somarhub.
c*******************************************************************************
#include "CONSTANTS.H"
#include "AddlFortranMacros.H"


! This will remove some of the clutter.
#ifdef IDX
#  error IDX needs to be renamed
#endif

#if CH_SPACEDIM == 2
#  define IDX(i,j) i,j

#elif CH_SPACEDIM == 3
#  define IDX(i,j) i,j,0

#else
#  error Bad SpaceDim
#endif


c ------------------------------------------------------------------------------
c     ui = rowIdx[0]  (u)
c     vi = rowIdx[1]  (v)
c     di = colIdx[0]  (div)
c     ci = colIdx[1]  (curl)
c     rx, ry = ref ratios in x and y dirs
c ------------------------------------------------------------------------------
      subroutine CFInterp_MatrixInvert_Original (
     &     CHF_FRA1[Minv],
     &     CHF_CONST_FIA1[ui],
     &     CHF_CONST_FIA1[vi],
     &     CHF_CONST_FIA1[di],
     &     CHF_CONST_FIA1[ci],
     &     CHF_CONST_REALVECT[dXi],
     &     CHF_CONST_INT[rx],
     &     CHF_CONST_INT[ry])

      integer i, j                           ! cell/face/node indices
      integer row, col                       ! matrix/vector indices
      integer rank                           ! M / Minv rank
      integer info                           ! LAPACK error code
      integer, dimension(0:iMinvhi0) :: ipiv ! pivot matrix from LAPACK
      REAL_T , dimension(0:iMinvhi0) :: work ! workspace for LAPACK

      rank = 2*rx*ry - (rx+ry)

      ! Start with all zeros.
      Minv(IDX(:,:)) = zero

      ! Div
      do j = 0, ry-1
        do i = 0, rx-1
          row = di(IDX(i,j))

          ! Skip linearly-dependent eq.
          if (row .lt. 0) cycle

          if (i .lt. rx-1) then
            ! add right u
            col = ui(IDX(i+1,j  ))
            Minv(IDX(row,col)) = +one / dXi(0)
          endif
          if (i .gt. 0) then
            ! remove left u
            col = ui(IDX(i  ,j  ))
            Minv(IDX(row,col)) = -one / dXi(0)
          endif
          if (j .lt. ry-1) then
            ! add top v
            col = vi(IDX(i  ,j+1))
            Minv(IDX(row,col)) = +one / dXi(1)
          endif
          if (j .gt. 0) then
            ! remove bottom v
            col = vi(IDX(i  ,j  ))
            Minv(IDX(row,col)) = -one / dXi(1)
          endif
        enddo
      enddo

      ! Curl
      if ((rx .gt. 1) .and. (ry .gt. 1)) then
          do j = 1, ry-1
            do i = 1, rx-1
              row = ci(IDX(i,j))

              ! right v in dv/dx
              col = vi(IDX(i  ,j  ))
              Minv(IDX(row,col)) = +one / dXi(0)

              ! left v in dv/dx
              col = vi(IDX(i-1,j  ))
              Minv(IDX(row,col)) = -one / dXi(0)

              ! top u in -du/dy
              col = ui(IDX(i  ,j  ))
              Minv(IDX(row,col)) = -one / dXi(1)

              ! bottom u in -du/dy
              col = ui(IDX(i  ,j-1))
              Minv(IDX(row,col)) = +one / dXi(1)
            enddo
          enddo
      endif

      ! LU factorization
      call dgetrf(rank, rank, Minv, rank, ipiv, info)

      if (info .gt. zero) then
        print*, 'dgetrf: The ', i,
     &          '-th diagional element is zero. ',
     &          'Matrix is singular.'
        call MAYDAYERROR()
      else if (info .lt. zero) then
        print*, 'dgetrf: The ', i,
     &          '-th parameter had an illegal value. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      endif

      ! Invert
      call dgetri(rank, Minv, rank, ipiv, work, rank, info)

      if (info .gt. zero) then
        print*, 'dgetri: The ', i,
     &          '-th diagional element of the factor U is zero. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      else if (info .lt. zero) then
        print*, 'dgetri: The ', i,
     &          '-th parameter had an illegal value. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      endif

      return
      end


c ------------------------------------------------------------------------------
c     ui = rowIdx[0]  (u)
c     vi = rowIdx[1]  (v)
c     di = colIdx[0]  (div)
c     ci = colIdx[1]  (curl)
c     rx, ry = ref ratios in x and y dirs
c ------------------------------------------------------------------------------
      subroutine CFInterp_MatrixInvert_StdLS (
     &     CHF_FRA1[Minv],
     &     CHF_FRA1[DC],
     &     CHF_FRA1[DCt],
     &     CHF_CONST_FIA1[ui],
     &     CHF_CONST_FIA1[vi],
     &     CHF_CONST_FIA1[di],
     &     CHF_CONST_FIA1[ci],
     &     CHF_CONST_REALVECT[dXi],
     &     CHF_CONST_INT[rx],
     &     CHF_CONST_INT[ry])

      integer i, j                           ! cell/face/node indices
      integer k
      integer row, col                       ! matrix/vector indices
      integer rank                           ! M / Minv rank
      integer info                           ! LAPACK error code
      integer, dimension(0:iMinvhi0) :: ipiv ! pivot matrix from LAPACK
      REAL_T , dimension(0:iMinvhi0) :: work ! workspace for LAPACK

      rank = 2*rx*ry - (rx+ry)

      ! Start with all zeros.
      Minv(IDX(:,:)) = zero
      DC(IDX(:,:)) = zero
      DCt(IDX(:,:)) = zero

      ! Div
      do j = 0, ry-1
        do i = 0, rx-1
          row = di(IDX(i,j))

          if (i .lt. rx-1) then
            ! add right u
            col = ui(IDX(i+1,j  ))
            DC(IDX(row,col)) = +one / dXi(0)
          endif
          if (i .gt. 0) then
            ! remove left u
            col = ui(IDX(i  ,j  ))
            DC(IDX(row,col)) = -one / dXi(0)
          endif
          if (j .lt. ry-1) then
            ! add top v
            col = vi(IDX(i  ,j+1))
            DC(IDX(row,col)) = +one / dXi(1)
          endif
          if (j .gt. 0) then
            ! remove bottom v
            col = vi(IDX(i  ,j  ))
            DC(IDX(row,col)) = -one / dXi(1)
          endif
        enddo
      enddo

      ! Curl
      if ((rx .gt. 1) .and. (ry .gt. 1)) then
          do j = 1, ry-1
            do i = 1, rx-1
              row = ci(IDX(i,j))

              ! right v in dv/dx
              col = vi(IDX(i  ,j  ))
              DC(IDX(row,col)) = +one / dXi(0)

              ! left v in dv/dx
              col = vi(IDX(i-1,j  ))
              DC(IDX(row,col)) = -one / dXi(0)

              ! top u in -du/dy
              col = ui(IDX(i  ,j  ))
              DC(IDX(row,col)) = -one / dXi(1)

              ! bottom u in -du/dy
              col = ui(IDX(i  ,j-1))
              DC(IDX(row,col)) = +one / dXi(1)
            enddo
          enddo
      endif

      ! DC transpose
      do j = 0, rank - 1
        do i = 0, rank
            DCt(IDX(j,i)) = DC(IDX(i,j))
        enddo
      enddo

      ! M (temporarily stored in Minv)
      do j = 0, rank - 1
        do i = 0, rank - 1
            do k = 0, rank
                Minv(IDX(i,j)) = Minv(IDX(i,j)) + DCt(IDX(i,k)) * DC(IDX(k,j))
            enddo
        enddo
      enddo

      ! LU factorization
      call dgetrf(rank, rank, Minv, rank, ipiv, info)

      if (info .gt. zero) then
        print*, 'dgetrf: The ', i,
     &          '-th diagional element is zero. ',
     &          'Matrix is singular.'
        call MAYDAYERROR()
      else if (info .lt. zero) then
        print*, 'dgetrf: The ', i,
     &          '-th parameter had an illegal value. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      endif

      ! Invert
      call dgetri(rank, Minv, rank, ipiv, work, rank, info)

      if (info .gt. zero) then
        print*, 'dgetri: The ', i,
     &          '-th diagional element of the factor U is zero. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      else if (info .lt. zero) then
        print*, 'dgetri: The ', i,
     &          '-th parameter had an illegal value. ',
     &          'Inversion not computed.'
        call MAYDAYERROR()
      endif

      return
      end

! ============================================================================
! CC ghost interpolation functions
! ============================================================================

C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
      subroutine CFInterp_HomogInterpAtCFI_Quad (
     &    CHF_FRA[phi],
     &    CHF_BOX[region],
     &    CHF_CONST_REAL[dxf],
     &    CHF_CONST_REAL[dxc],
     &    CHF_CONST_INT[idir],
     &    CHF_CONST_INT[ihilo])

      REAL_T c1, c2
      REAL_T pa, pb
      INTEGER ncomp,  n
      INTEGER CHF_AUTODECL[ii]
      INTEGER CHF_AUTODECL[i]

      c1 = two*(dxc-dxf)/(dxc+dxf)
      c2 =    -(dxc-dxf)/(dxc+three*dxf)
      ihilo = ihilo*(-1)
      ncomp = CHF_NCOMP[phi]
      CHF_AUTOID[ii; idir; ihilo]

      do n = 0, ncomp-1
        CHF_AUTOMULTIDO[region; i]
          pa=phi(CHF_OFFSETIX[i;+ii],n)
          pb=phi(CHF_OFFSETIX[i;+2*ii],n)
          phi(CHF_AUTOIX[i],n) = c1*pa + c2*pb
        CHF_ENDDO
      enddo

      return
      end



C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
      subroutine CFInterp_HomogInterpAtCFI_Linear(
     &    CHF_FRA[phi],
     &    CHF_BOX[region],
     &    CHF_CONST_REAL[dxf],
     &    CHF_CONST_REAL[dxc],
     &    CHF_CONST_INT[idir],
     &    CHF_CONST_INT[ihilo])

      INTEGER ncomp,  n
      INTEGER CHF_AUTODECL[ii]
      INTEGER CHF_AUTODECL[i]

      REAL_T pa, factor

      ihilo = ihilo*(-1)

      ncomp = CHF_NCOMP[phi]
      CHF_AUTOID[ii; idir; ihilo]

      factor = one - two*dxf/(dxf+dxc)
      do n = 0, ncomp-1
        CHF_AUTOMULTIDO[region; i]
          pa=phi(CHF_OFFSETIX[i;+ii],n)
          phi(CHF_AUTOIX[i],n) = factor*pa
        CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! CC refinement functions
! ============================================================================

c ------------------------------------------------------------------------------
c piecewise constant interpolation
c ------------------------------------------------------------------------------
      subroutine CFInterp_unmappedinterpconstant(
     &     CHF_FRA[fine],
     &     CHF_CONST_FRA[coarse],
     &     CHF_BOX[coarseBox],
     &     CHF_CONST_INTVECT[ref_ratio],
     &     CHF_BOX[bref])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[if]
      integer CHF_AUTODECL[ii]

      ! compute on the refined box of each coarse point
      do var = 0, CHF_NCOMP[coarse] - 1
         CHF_AUTOMULTIDO[coarseBox;ic]
            CHF_AUTOMULTIDO[bref; ii]
              CHF_DTERM[
              if0 = ic0*ref_ratio(0) + ii0;
              if1 = ic1*ref_ratio(1) + ii1;
              if2 = ic2*ref_ratio(2) + ii2]

              fine(CHF_AUTOIX[if],var) = coarse(CHF_AUTOIX[ic],var)
            CHF_ENDDO
         CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c piecewise bi-(tri-)linear interpolation to "fine" assuming that
c piecewise constant interpolation has already been done
c ------------------------------------------------------------------------------
      subroutine CFInterp_unmappedinterplinear(
     &     CHF_FRA[fine],
     &     CHF_CONST_FRA[slope],
     &     CHF_BOX[b],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INTVECT[ref_ratio],
     &     CHF_BOX[bref])

      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[if]
      integer CHF_AUTODECL[ii]
      integer var, id
      REAL_T dxf

      do var = 0, CHF_NCOMP[fine] - 1
        CHF_AUTOMULTIDO[b;ic]
          CHF_AUTOMULTIDO[bref;ii]

            CHF_DTERM[
            if0 = ic0*ref_ratio(0) + ii0;
            if1 = ic1*ref_ratio(1) + ii1;
            if2 = ic2*ref_ratio(2) + ii2]

            CHF_DTERM[
            if (dir .eq. 0) then
              id = ii0;
            else if (dir .eq. 1) then
              id = ii1;
            else if (dir .eq. 2) then
              id = ii2]
            endif

            dxf = -half + ( (id+half) / ref_ratio(dir) );

            fine(CHF_AUTOIX[if],var) =
     &          fine(CHF_AUTOIX[if],var) +
     &          dxf * slope(CHF_AUTOIX[ic], var)
          CHF_ENDDO
        CHF_ENDDO
      enddo

      return
      end



c
c calculate slopes with central difference formula
c
      subroutine CFInterp_interpcentralslope (
     &     CHF_FRA [slope],
     &     CHF_CONST_FRA[state],
     &     CHF_BOX[b],
     &     CHF_CONST_INT[dir]
     &     )

      integer CHF_AUTODECL[i]
      integer CHF_AUTODECL[ii]
      integer var

      CHF_AUTOID[ii; dir]

      do var = 0, CHF_NCOMP[state] - 1
         CHF_AUTOMULTIDO [ b; i]

          slope (CHF_AUTOIX[i],var) = half * (
     &        state (CHF_OFFSETIX[i;+ii],var) -
     &        state (CHF_OFFSETIX[i;-ii],var) )

          CHF_ENDDO
       enddo

      return
      end
c
c calculate slopes with high one-sided difference formula
c
      subroutine CFInterp_interphisideslope (
     &     CHF_FRA [slope],
     &     CHF_CONST_FRA [state],
     &     CHF_BOX[b],
     &     CHF_CONST_INT [dir]
     &     )

      integer CHF_AUTODECL[i]
      integer CHF_AUTODECL[ii]
      integer var

      CHF_AUTOID[ii; dir]

      do var = 0, CHF_NCOMP[state] - 1
         CHF_AUTOMULTIDO [ b; i]

          slope (CHF_AUTOIX[i],var) =
     &          state ( CHF_OFFSETIX[i;+ii], var)
     &        - state ( CHF_AUTOIX[i], var)

          CHF_ENDDO
       enddo

      return
      end
c
c calculate slopes with low one-sided difference formula
c
      subroutine CFInterp_interplosideslope (
     &     CHF_FRA [slope],
     &     CHF_CONST_FRA [state],
     &     CHF_BOX[b],
     &     CHF_CONST_INT [dir]
     &     )

      integer CHF_AUTODECL[i], var
      integer CHF_AUTODECL[ii]

      CHF_AUTOID[ii; dir]

      do var = 0, CHF_NCOMP[state] - 1
         CHF_AUTOMULTIDO [ b; i]

         slope (CHF_AUTOIX[i],var) =
     &        state ( CHF_AUTOIX[ i ], var) -
     &        state ( CHF_OFFSETIX[ i;-ii], var)
          CHF_ENDDO
       enddo

      return
      end


c
c multidimensional limiting
c
c bn:  box which spans the neighbors of a cell (generally (-1,1) in
c      each coordinate direction
c bcoarse: coarse-level box over which to limit slopes
c

      subroutine CFInterp_interplimit (
     &     CHF_FRA [ islope ],
     &     CHF_FRA [ jslope ],
     &     CHF_FRA [ kslope ],
     &     CHF_CONST_FRA [ state ],
     &     CHF_BOX [ bcoarse ],
     &     CHF_BOX [ bn ],
     &     CHF_BOX [ physdomain]
     &     )

      integer CHF_AUTODECL [i], var
      integer CHF_AUTODECL [ii]
      integer CHF_AUTODECL [in]
      REAL_T statemax, statemin, deltasum,  eta
c       REAL_T tempone, tempzero, minuscule

c       tempone = one
c       tempzero = zero
c       minuscule = 1.e-12

      do var = 0, CHF_NCOMP[ islope ] - 1
         CHF_AUTOMULTIDO [ bcoarse; i]
             statemax = state ( CHF_AUTOIX[i], var )
             statemin = state ( CHF_AUTOIX[i], var )

             CHF_AUTOMULTIDO [ bn; ii ]

             CHF_DTERM[
                 in0 = i0 + ii0;
                 in1 = i1 + ii1;
                 in2 = i2 + ii2;
                 in3 = i3 + ii3;
                 in4 = i4 + ii4;
                 in5 = i5 + ii5 ]


                 if (
                 CHF_DTERM[
     &                in0 .ge. CHF_LBOUND[ state; 0 ] .and.
     &                in0 .le. CHF_UBOUND[ state; 0 ] ;
     &                .and.
     &                in1 .ge. CHF_LBOUND[state; 1 ] .and.
     &                in1 .le. CHF_UBOUND[ state; 1 ] ;
     &                .and.
     &                in2 .ge. CHF_LBOUND[ state; 2 ] .and.
     &                in2 .le. CHF_UBOUND[ state; 2 ] ;
     &                .and.
     &                in3 .ge. CHF_LBOUND[state; 3 ] .and.
     &                in3 .le. CHF_UBOUND[ state; 3 ] ;
     &                .and.
     &                in4 .ge. CHF_LBOUND[state; 4 ] .and.
     &                in4 .le. CHF_UBOUND[ state; 4 ] ;
     &                .and.
     &                in5 .ge. CHF_LBOUND[state; 5 ] .and.
     &                in5 .le. CHF_UBOUND[ state; 5 ] ]
     &                ) then
                    statemax = max ( statemax, state(CHF_AUTOIX[in],var))
                    statemin = min ( statemin, state(CHF_AUTOIX[in],var))
                 endif
             CHF_ENDDO
             deltasum = half * (
                CHF_DTERM[
     &            abs ( islope ( CHF_AUTOIX[i], var ) );
     &            +
     &            abs ( jslope ( CHF_AUTOIX[i], var ) );
     &            +
     &            abs ( kslope ( CHF_AUTOIX[i], var ) );
     &            +
     &            abs ( islope ( CHF_AUTOIX[i], var ) );
     &            +
     &            abs ( jslope ( CHF_AUTOIX[i], var ) );
     &            +
     &            abs ( kslope ( CHF_AUTOIX[i], var ) );  ]
     &            )

c  note that this has not been extended to work for DIM > 3
#if CH_SPACEDIM > 3
                call MAYDAY_ERROR()
#endif

c
c (TJL) the slope limiting is being done differently to avoid the problem(s)
c GHM mentions below.
c
c              if ( deltasum .gt. zero ) then
c c
c c (GHM) deltasum can be arbitrarily small, while the numerator
c c statemax-state can be arbitrarily large, and so an FP overflow
c c may occur (this happens when state is a local extrema).
c c since eta is limited to <=tempone anyway, rewrite to avoid FPE.
c c
c c               etamax = ( statemax - state ( CHF_IX[i;j;k], var ) )
c c    &               / deltasum
c c               etamin = ( state ( CHF_IX[i;j;k], var ) - statemin )
c c    &               / deltasum
c                 deltasum = max(deltasum,minuscule)
c                 etamax = min( statemax - state ( CHF_IX[i;j;k], var ),
c      &                   tempone*deltasum )
c                 etamax = etamax/deltasum
c                 etamin = min( state ( CHF_IX[i;j;k], var ) - statemin,
c      &                   tempone*deltasum )
c                 etamin = etamin/deltasum
c                 eta = max ( min ( etamin, etamax, tempone ), tempzero )

              eta = min(statemax - state(CHF_AUTOIX[i],var),
     &                  state(CHF_AUTOIX[i],var) - statemin)

c Believe it or not, the following data snuck past the (deltasum>eta)
c test, then did a divide by zero.  Apparently not all zeros are
c created equal.
c deltasum=  0.0000000000000000E+000 eta=  0.0000000000000000E+000
c This result was obtained in a test using double precision with
c pgf77.  This error did not occur with the same initial conditions
c using double precision, but g77.  Go figure.  To fix this problem,
c I reckon that if eta and deltasum are both close to zero, we ought
c to limit fully ...
c GHM 9/5/02
              if( eta .le. 1.e-9*abs(statemax) ) then
                 eta = zero
              else

              if (deltasum .gt. eta) then
                eta = eta/deltasum
              else
                eta = one
              endif

c GHM 9/5/02
              endif

c
c (TJL) this needs to be revisited.
c
c c ::: design decision not to limit slopes near physical boundaries
c c               now enforced in FineInterp() calling function
c c               by modification of the box size bcoarse.
c c               GHM 7/12/01
c
c c               CHF_DTERM[
c c               if (i.eq.CHF_LBOUND[physdomain;0]) then
c c                  eta = one
c c               else if (i.eq.CHF_UBOUND[physdomain;0]) then
c c                  eta = one ;
c c               else if (j.eq.CHF_LBOUND[physdomain;1]) then
c c                  eta = one
c c               else if (j.eq.CHF_UBOUND[physdomain;1]) then
c c                  eta = one ;
c c               else if (k.eq.CHF_LBOUND[physdomain;2]) then
c c                  eta = one
c c               else if (k.eq.CHF_UBOUND[physdomain;2]) then
c c                  eta = one ]
c c               endif

              CHF_DTERM[
              islope ( CHF_AUTOIX[i], var ) =
     &             eta * islope ( CHF_AUTOIX[i], var ) ;
              jslope ( CHF_AUTOIX[i], var ) =
     &             eta * jslope ( CHF_AUTOIX[i], var ) ;
              kslope ( CHF_AUTOIX[i], var ) =
     &             eta * kslope ( CHF_AUTOIX[i], var ) ;
              islope ( CHF_AUTOIX[i], var ) =
     &             eta * islope ( CHF_AUTOIX[i], var ) ;
              jslope ( CHF_AUTOIX[i], var ) =
     &             eta * jslope ( CHF_AUTOIX[i], var ) ;
              kslope ( CHF_AUTOIX[i], var ) =
     &             eta * kslope ( CHF_AUTOIX[i], var )  ]
c              end if

c note that this also hasn't been fixed to run for DIM > 3
#if CH_SPACEDIM > 3
              call MAYDAY_ERROR()
#endif

         CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! FC refinement functions
! ============================================================================

c ------------------------------------------------------------------------------
c piecewise constant interpolation -- this only fills in
c data on faces which overlie coarse faces.  Intermediate
c faces will be filled in later.  This is actually exactly
c the same as interp_constant, i think!
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedInterpFaceConstant(
     &     CHF_FRA[fine],
     &     CHF_CONST_FRA[coarse],
     &     CHF_BOX[coarseBox],
     &     CHF_CONST_INTVECT[ref_ratio],
     &     CHF_BOX[bref],
     &     CHF_CONST_INT[dir]
     &     )

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ifine]
      integer CHF_AUTODECL[ii]


c compute on the refined face of each coarse face
      do var = 0, CHF_NCOMP[coarse] - 1
         CHF_AUTOMULTIDO[coarseBox; ic]
            CHF_AUTOMULTIDO[bref; ii]
            CHF_DTERM[
               ifine0 = ic0*ref_ratio(0) + ii0;
               ifine1 = ic1*ref_ratio(1) + ii1;
               ifine2 = ic2*ref_ratio(2) + ii2]

               fine(CHF_AUTOIX[ifine],var) = coarse(CHF_AUTOIX[ic],var)
            CHF_ENDDO
         CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c piecewise bi-(tri-)linear interpolation to "fine" assuming that
c piecewise constant interpolation has already been done
c this is probably also the same as the basic interp_linear subroutine
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedInterpLinearFace (
     &     CHF_FRA[fine],
     &     CHF_CONST_FRA[slope],
     &     CHF_BOX[b],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INTVECT[ref_ratio],
     &     CHF_BOX[brefface]
     &     )

      integer CHF_AUTODECL[ ic ]
      integer CHF_AUTODECL[ ifine ]
      integer CHF_AUTODECL[ ii ]
      integer var, id

      REAL_T dxf
c this is a box that will go from (0,0,0) to (ref_ratio-1)*(1,1,1)

c compute on the refined edges of each coarse edge
      do var = 0, CHF_NCOMP[fine] - 1
         CHF_AUTOMULTIDO[ b; ic ]

              CHF_AUTOMULTIDO[ brefface; ii ]

              CHF_DTERM[
                  ifine0 = ic0*ref_ratio(0) + ii0;
                  ifine1 = ic1*ref_ratio(1) + ii1;
                  ifine2 = ic2*ref_ratio(2) + ii2]


              CHF_DTERM[
                  if (dir .eq. 0) then
                      id = ii0;
                  else if (dir .eq. 1) then
                      id = ii1;
                  else if (dir .eq. 2) then
                      id = ii2]
                  endif

              dxf = -half + ( (id+half) / ref_ratio(dir) )
              fine(CHF_AUTOIX[ifine],var) =
     &                 fine(CHF_AUTOIX[ifine],var) +
     &                 dxf * slope(CHF_AUTOIX[ic], var)
              CHF_ENDDO
          CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c  this subroutine will do linear interpolation in the normal
c  direction for interior faces (faces which do not overlie a
c  coarse face).  assumes that "exterior" face interpolation
c  has already been done.
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedInterpLinearInteriorFace(
     &    CHF_FRA[fine],
     &    CHF_BOX[bcoarse],
     &    CHF_CONST_INTVECT[ref_ratio],
     &    CHF_CONST_INT[facedir],
     &    CHF_BOX[interiorrefbox]
     &    )

      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ifine]
      integer CHF_AUTODECL[ii]
      integer CHF_AUTODECL[iloface]
      integer CHF_AUTODECL[ihiface]
      integer var, id

      REAL_T dxf, diff
      REAL_T loval, hival

      do var=0, CHF_NCOMP[fine] -1
         CHF_AUTOMULTIDO[bcoarse; ic]
            CHF_AUTOMULTIDO[interiorrefbox; ii]

            CHF_DTERM[
              ifine0 = ic0*ref_ratio(0) + ii0;
              ifine1 = ic1*ref_ratio(1) + ii1;
              ifine2 = ic2*ref_ratio(2) + ii2]


c             this will be the coordinates of the low "exterior" face
              CHF_DTERM[
              iloface0 = ic0*ref_ratio(0) + (1-CHF_ID(0,facedir))*ii0;
              iloface1 = ic1*ref_ratio(1) + (1-CHF_ID(1,facedir))*ii1;
              iloface2 = ic2*ref_ratio(2) + (1-CHF_ID(2,facedir))*ii2]


c             this will be the coordinates of the hi "exterior" face
              CHF_DTERM[
              ihiface0 = iloface0 + ref_ratio(0)*CHF_ID(0,facedir);
              ihiface1 = iloface1 + ref_ratio(1)*CHF_ID(1,facedir);
              ihiface2 = iloface2 + ref_ratio(2)*CHF_ID(2,facedir)]

              CHF_DTERM[
              if (facedir .eq. 0) then
                 id = ii0;
              else if (facedir .eq. 1) then
                 id = ii1;
              else if (facedir .eq. 2) then
                 id = ii2]
              endif

              dxf = dble(id)/dble(ref_ratio(facedir))
              diff = fine(CHF_AUTOIX[ihiface],var)
     &             - fine(CHF_AUTOIX[iloface],var)

              fine(CHF_AUTOIX[ifine],var) = fine(CHF_AUTOIX[iloface],var)
     &                                    + dxf * diff

            CHF_ENDDO
          CHF_ENDDO

       enddo

       return
       end


c ------------------------------------------------------------------------------
c  this subroutine will do cubic interpolation in the normal
c  direction for interior faces (faces which do not overlie a
c  coarse face).  assumes that "exterior" face interpolation
c  has already been done.
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedInterpCubicInteriorFace(
     &    CHF_FRA[fine],
     &    CHF_BOX[bcoarse],
     &    CHF_CONST_INTVECT[ref_ratio],
     &    CHF_CONST_INT[facedir],
     &    CHF_BOX[interiorrefbox]
     &    )

      integer CHF_AUTODECL[ic]   ! lower coarse-level face
      integer CHF_AUTODECL[ii]   ! fine-level offset from lower parent
      integer CHF_AUTODECL[if]   ! fine-level face to be interpolated

      integer CHF_AUTODECL[ifll] ! fine-level face overlying parent
      integer CHF_AUTODECL[ifl]  ! fine-level face overlying parent
      integer CHF_AUTODECL[ifr]  ! fine-level face overlying parent
      integer CHF_AUTODECL[ifrr] ! fine-level face overlying parent

      integer var, id

      REAL_T ull, ul, ur, urr   ! fine-level data overlying parent
      REAL_T a, b, c, d
      REAL_T x

      do var = 0, CHF_NCOMP[fine] - 1
         CHF_AUTOMULTIDO[bcoarse; ic]
            CHF_AUTOMULTIDO[interiorrefbox; ii]
              ! The current fine face to be interpolated.
              CHF_DTERM[
              if0 = ic0*ref_ratio(0) + ii0;
              if1 = ic1*ref_ratio(1) + ii1;
              if2 = ic2*ref_ratio(2) + ii2]

c             coordinates of the lower, fine-level parent face
              CHF_DTERM[
              ifl0 = ic0*ref_ratio(0) + (1-CHF_ID(0,facedir))*ii0;
              ifl1 = ic1*ref_ratio(1) + (1-CHF_ID(1,facedir))*ii1;
              ifl2 = ic2*ref_ratio(2) + (1-CHF_ID(2,facedir))*ii2]

c             coordinates of the upper, fine-level parent face
              CHF_DTERM[
              ifr0 = ifl0 + ref_ratio(0)*CHF_ID(0,facedir);
              ifr1 = ifl1 + ref_ratio(1)*CHF_ID(1,facedir);
              ifr2 = ifl2 + ref_ratio(2)*CHF_ID(2,facedir)]

c             coordinates of the next lower, fine-level parent face
              CHF_DTERM[
              ifll0 = ic0*ref_ratio(0) + (1-CHF_ID(0,facedir))*ii0;
              ifll1 = ic1*ref_ratio(1) + (1-CHF_ID(1,facedir))*ii1;
              ifll2 = ic2*ref_ratio(2) + (1-CHF_ID(2,facedir))*ii2]

c             coordinates of the next upper, fine-level parent face
              CHF_DTERM[
              ifrr0 = ifl0 + ref_ratio(0)*CHF_ID(0,facedir);
              ifrr1 = ifl1 + ref_ratio(1)*CHF_ID(1,facedir);
              ifrr2 = ifl2 + ref_ratio(2)*CHF_ID(2,facedir)]

              ull = fine(CHF_AUTOIX[ifll],var)
              ul  = fine(CHF_AUTOIX[ifl] ,var)
              ur  = fine(CHF_AUTOIX[ifr] ,var)
              urr = fine(CHF_AUTOIX[ifrr],var)

              CHF_DTERM[
              if (facedir .eq. 0) then
                 id = ii0;
              else if (facedir .eq. 1) then
                 id = ii1;
              else if (facedir .eq. 2) then
                 id = ii2]
              endif

              x = dble(id) / dble(ref_ratio(facedir))

            !   fine(CHF_AUTOIX[if],var) = ul + (ur-ul)*x

              a = (              six*ul               ) * sixth
              b = (-  two*ull -three*ul +  six*ur -urr) * sixth
              c = ( three*ull -  six*ul +three*ur     ) * sixth
              d = (-      ull +three*ul -three*ur +urr) * sixth
              fine(CHF_AUTOIX[if],var) = ((d*x + c)*x + b)*x + a

            CHF_ENDDO
          CHF_ENDDO

       enddo

       return
       end


c ------------------------------------------------------------------------------
c multidimensional limiting, same as interp_limit except that we
c don't even touch slopes in normal direction (just along faces)
c
c Also need to make sure that all faces are w/in physical domain
c
c bn is a box of the neighbors on this face
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedInterpLimitFace (
     &     CHF_FRA [ islope ],
     &     CHF_FRA [ jslope ],
     &     CHF_FRA [ kslope ],
     &     CHF_CONST_FRA [ state ],
     &     CHF_BOX [ b ],
     &     CHF_BOX [ bn ],
     &     CHF_BOX [validBox],
     &     CHF_CONST_INT[normaldir]
     &     )

      integer CHF_AUTODECL [ i ], var
      integer CHF_AUTODECL [ ii ]
      integer CHF_AUTODECL [ in ]
      REAL_T statemax, statemin, deltasum, etamax, etamin, eta
      REAL_T tempone, tempzero

      tempone = one
      tempzero = zero


      do var = 0, CHF_NCOMP[ islope ] - 1
         CHF_AUTOMULTIDO [ b; i]
             statemax = state ( CHF_AUTOIX[i], var )
             statemin = state ( CHF_AUTOIX[i], var )

             CHF_AUTOMULTIDO [ bn; ii]

             CHF_DTERM[
                 in0 = i0 + ii0;
                 in1 = i1 + ii1;
                 in2 = i2 + ii2]

                 if (
                 CHF_DTERM[
     &                in0 .ge. CHF_LBOUND[ validBox; 0 ] .and.
     &                in0 .le. CHF_UBOUND[ validBox; 0 ] ;
     &                .and.
     &                in1 .ge. CHF_LBOUND[ validBox; 1 ] .and.
     &                in1 .le. CHF_UBOUND[ validBox; 1 ] ;
     &                .and.
     &                in2 .ge. CHF_LBOUND[ validBox; 2 ] .and.
     &                in2 .le. CHF_UBOUND[ validBox; 2 ] ]
     &                )
     &        then
                    statemax = max ( statemax, state(CHF_AUTOIX[in],var))
                    statemin = min ( statemin, state(CHF_AUTOIX[in],var))
                 endif
             CHF_ENDDO

c ::: note that we filter out the slopes in the normal direction
             deltasum = half * (
                CHF_DTERM[
     &            (1-CHF_ID(normaldir,0))*abs(islope(CHF_AUTOIX[i],var));
     &            +
     &            (1-CHF_ID(normaldir,1))*abs(jslope(CHF_AUTOIX[i],var));
     &            +
     &            (1-CHF_ID(normaldir,2))*abs(kslope(CHF_AUTOIX[i],var))]
     &            )
             if ( deltasum .gt. zero ) then
                etamax = ( statemax - state ( CHF_AUTOIX[i], var ) )
     &               / deltasum
                etamin = ( state ( CHF_AUTOIX[i], var ) - statemin )
     &               / deltasum
                eta = max ( min ( etamin, etamax, tempone ), tempzero )

                CHF_DTERM[
                islope ( CHF_AUTOIX[i], var ) =
     &               eta * islope ( CHF_AUTOIX[i], var ) ;
                jslope ( CHF_AUTOIX[i], var ) =
     &               eta * jslope ( CHF_AUTOIX[i], var ) ;
                kslope ( CHF_AUTOIX[i], var ) =
     &               eta * kslope ( CHF_AUTOIX[i], var ) ]
             end if
         CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! CC Coarsening functions
! ============================================================================

c ------------------------------------------------------------------------------
c Performs averaging of data from fine to coarse level.
c TODO: Unroll the inner loop for common refRatios
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedAverage (
     &     CHF_FRA[coarse],
     &     CHF_CONST_FRA[fine],
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[refRatio],
     &     CHF_BOX[bref])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      REAL_T refScale, coarseSum

      refScale = one / DBLE(CHF_DTERM[refRatio(0);*refRatio(1);*refRatio(2)])

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[box;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarseSum = zero

          ! loop over fine grid faces and compute sum
          CHF_AUTOMULTIDO[ bref; ii ]
            coarseSum = coarseSum + fine( CHF_OFFSETIX[ip;+ii],var)
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = coarseSum * refScale
        CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c Performs harmonic averaging of data from fine to coarse level.
c TODO: Unroll the inner loop for common refRatios
c ------------------------------------------------------------------------------
      subroutine CFInterp_UnmappedAverageHarmonic (
     &     CHF_FRA[coarse],
     &     CHF_CONST_FRA[fine],
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[refRatio],
     &     CHF_BOX[bref])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      REAL_T refScale, coarseSum

      refScale = one / DBLE(CHF_DTERM[refRatio(0);*refRatio(1);*refRatio(2)])

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[box;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarseSum = zero

          ! loop over fine grid faces and compute sum
          CHF_AUTOMULTIDO[bref; ii]
            coarseSum = coarseSum + one / fine(CHF_OFFSETIX[ip;+ii],var)
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = one / (coarseSum * refScale)
        CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c Performs a cell-volume weighted average of fine data to coarse level.
c TODO: Unroll the inner loop for common refRatios
c ------------------------------------------------------------------------------
      subroutine CFInterp_MappedAverage (
     &     CHF_FRA[coarse],
     &     CHF_CONST_FRA[fine],
     &     CHF_CONST_FRA1[fineCCJ],
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[refRatio],
     &     CHF_BOX[bref])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      REAL_T coarseSum, coarseCCJSum

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[box;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarseSum = zero
          coarseCCJSum = zero

          ! loop over fine grid faces and compute sums
          CHF_AUTOMULTIDO[bref;ii]
            coarseSum = coarseSum + fine(CHF_OFFSETIX[ip;+ii],var) * fineCCJ(CHF_OFFSETIX[ip;+ii])
            coarseCCJSum = coarseCCJSum + fineCCJ(CHF_OFFSETIX[ip;+ii])
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = coarseSum / coarseCCJSum
        CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! FC Coarsening functions
! ============================================================================

c --------------------------------------------------------------
c  this subroutine averages face-centered fine grid data onto
c  underlying coarse-grid faces in direction dir
c
c  INPUTS/OUTPUTS:
c  fine      => fine-grid data
c  coarse   <=  coarse data
c  crseBox   => face-centered coarse box over which to average
c  dir       => direction of face-centered data (0 = x-faces)
c  refRatio  => refinement ratio
c  refBox    => utility box, goes from (0,nref-1) in all directions
c --------------------------------------------------------------
      subroutine CFInterp_UnmappedAverageFace (
     &      CHF_FRA[coarse],
     &      CHF_CONST_FRA[fine],
     &      CHF_BOX[crseBox],
     &      CHF_CONST_INT[dir],
     &      CHF_CONST_INTVECT[refRatio],
     &      CHF_BOX[refBox])


      ! local variables
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      integer var
      REAL_T crseSum, refScale

      refScale = DBLE(refRatio(dir))
     &         / DBLE(CHF_DTERM[refRatio(0);*refRatio(1);*refRatio(2)])

      do var = 0, CHF_NCOMP[coarse]-1
        CHF_AUTOMULTIDO[crseBox;ic]
          CHF_DTERM[
          ip0 = ic0 * refRatio(0);
          ip1 = ic1 * refRatio(1);
          ip2 = ic2 * refRatio(2)]

          crseSum = zero

          ! loop over fine grid faces and compute sum
          CHF_AUTOMULTIDO[refBox;ii]
            crseSum = crseSum + fine(CHF_OFFSETIX[ip;+ii],var)
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = refScale * crseSum

        CHF_ENDDO
      enddo

      return
      end


c --------------------------------------------------------------
c  this subroutine averages face-centered fine grid data onto
c  underlying coarse-grid faces in direction dir using harmonic
c  averaging
c
c  INPUTS/OUTPUTS:
c  fine      => fine-grid data
c  coarse   <=  coarse data
c  crseBox   => face-centered coarse box over which to average
c  dir       => direction of face-centered data (0 = x-faces)
c  refRatio  => refinement ratio
c  refBox    => utility box, goes from (0,nref-1) in all directions
c --------------------------------------------------------------
      subroutine CFInterp_UnmappedAverageFaceHarmonic (
     &      CHF_FRA[coarse],
     &      CHF_CONST_FRA[fine],
     &      CHF_BOX[crseBox],
     &      CHF_CONST_INT[dir],
     &      CHF_CONST_INTVECT[refRatio],
     &      CHF_BOX[refBox])


      ! local variables
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      integer var
      REAL_T crseSum, refScale

      refScale = DBLE(refRatio(dir))
     &         / DBLE(CHF_DTERM[refRatio(0);*refRatio(1);*refRatio(2)])

      do var = 0, CHF_NCOMP[coarse]-1
        CHF_AUTOMULTIDO[crseBox;ic]
          CHF_DTERM[
          ip0 = ic0 * refRatio(0);
          ip1 = ic1 * refRatio(1);
          ip2 = ic2 * refRatio(2)]

          crseSum = zero

         ! loop over fine grid faces and compute sum
         CHF_AUTOMULTIDO[refBox;ii]
            crseSum = crseSum + one / fine(CHF_OFFSETIX[ip;+ii],var)
         CHF_ENDDO

         coarse(CHF_AUTOIX[ic],var) = one / (refScale * crseSum)

        CHF_ENDDO
      enddo

      return
      end


c ------------------------------------------------------------------------------
c Performs an area-weighted average of fine, FC data to a coarse level.
c TODO: Unroll the inner loop for common refRatios
c ------------------------------------------------------------------------------
      subroutine CFInterp_MappedAverageFace (
     &     CHF_FRA[coarse],
     &     CHF_CONST_FRA[fine],
     &     CHF_CONST_FRA1[fineFCJ],
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INTVECT[refRatio],
     &     CHF_BOX[bref])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      REAL_T coarseSum, coarseFCJSum

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[box;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarseSum = zero
          coarseFCJSum = zero

          ! loop over fine grid faces and compute sums
          CHF_AUTOMULTIDO[bref;ii]
            coarseSum = coarseSum + fine(CHF_OFFSETIX[ip;+ii],var) * fineFCJ(CHF_OFFSETIX[ip;+ii])
            coarseFCJSum = coarseFCJSum + fineFCJ(CHF_OFFSETIX[ip;+ii])
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = coarseSum / coarseFCJSum
        CHF_ENDDO
      enddo

      return
      end


c ----------------------------------------------------------------------------
c  Performs the last step in CFInterp::validateAtCoarseCFI. See that function
c  most for details.
c
c  destFAB is the FC holder shifted so the bdry box is in the CC ghost.
c  exFAB is the CC exchanged data.
c  ghostBox is the CC ghost adjacent to the boundary we are validating.
c  bdrySign must be +1 or -1.
c ----------------------------------------------------------------------------
      subroutine CFInterp_CopyMaskedDataToBdryFaces (
     &     CHF_FRA[destFAB],
     &     CHF_CONST_FRA[exFAB],
     &     CHF_CONST_FIA1[maskFAB],
     &     CHF_BOX[ghostBox],
     &     CHF_CONST_INT[bdryDir],
     &     CHF_CONST_INT[bdrySign])

      integer var, gmask, vmask
      integer CHF_AUTODECL[ig]
      integer CHF_AUTODECL[ii]

      CHF_AUTOID[ii; bdryDir]
      CHF_DTERM[
      ii0 = bdrySign * ii0;
      ii1 = bdrySign * ii1;
      ii2 = bdrySign * ii2]

      do var = 0, CHF_NCOMP[destFAB] - 1
        CHF_AUTOMULTIDO[ghostBox;ig]
          gmask = maskFAB(CHF_AUTOIX[ig])
          vmask = maskFAB(CHF_OFFSETIX[ig; -ii])

          if (gmask .eq. vmask) cycle

          if (gmask .eq. 1) then
            destFAB(CHF_AUTOIX[ig],var) = exFAB(CHF_AUTOIX[ig],var)
          endif
        CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! NC Coarsening functions
! ============================================================================

c ------------------------------------------------------------------------------
c Injection. It just copies fine data to the coarse level.
c ------------------------------------------------------------------------------
      subroutine CFInterp_InterpToCoarseNodes (
     &     CHF_FRA[coarse],
     &     CHF_CONST_FRA[fine],
     &     CHF_BOX[crseBox],
     &     CHF_CONST_INTVECT[refRatio])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[crseBox;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarse(CHF_AUTOIX[ic],var) = fine(CHF_AUTOIX[ip],var)
        CHF_ENDDO
      enddo

      return
      end


! ============================================================================
! EC Coarsening functions
! ============================================================================

c --------------------------------------------------------------
c  this subroutine averages edge-centered fine grid data onto
c  underlying coarse-grid faces in direction dir
c
c  INPUTS/OUTPUTS:
c  fine      => fine-grid data
c  coarse   <=  coarse data
c  crseBox   => edge-centered coarse box over which to average
c  edgeDir   => direction of edge-centered data (0 = x-edges, ...)
c               In other words, CC in this dir, NC in all others.
c  refRatio  => refinement ratio
c  refBox    => utility box, goes from (0,nref-1) in all directions
c --------------------------------------------------------------
      subroutine CFInterp_UnmappedAverageEdge (
     &      CHF_FRA[coarse],
     &      CHF_CONST_FRA[fine],
     &      CHF_BOX[crseBox],
     &      CHF_CONST_INT[edgeDir],
     &      CHF_CONST_INTVECT[refRatio],
     &      CHF_BOX[refBox])


      ! local variables
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      integer var
      REAL_T crseSum, refScale

      refScale = one / DBLE(refRatio(edgeDir))

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[crseBox;ic]
          CHF_DTERM[
          ip0 = ic0 * refRatio(0);
          ip1 = ic1 * refRatio(1);
          ip2 = ic2 * refRatio(2)]

          crseSum = zero

          ! loop over fine grid faces and compute sum
          CHF_AUTOMULTIDO[refBox;ii]
            crseSum = crseSum + fine(CHF_OFFSETIX[ip;+ii],var)
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = refScale * crseSum

        CHF_ENDDO
      enddo

      return
      end


c --------------------------------------------------------------
c  this subroutine averages edge-centered fine grid data onto
c  underlying coarse-grid faces in direction dir
c
c  INPUTS/OUTPUTS:
c  fine      => fine-grid data
c  coarse   <=  coarse data
c  crseBox   => edge-centered coarse box over which to average
c  edgeDir   => direction of edge-centered data (0 = x-edges, ...)
c               In other words, CC in this dir, NC in all others.
c  refRatio  => refinement ratio
c  refBox    => utility box, goes from (0,nref-1) in all directions
c --------------------------------------------------------------
      subroutine CFInterp_MappedAverageEdge (
     &      CHF_FRA[coarse],
     &      CHF_CONST_FRA[fine],
     &      CHF_CONST_FRA1[fineECJ],
     &      CHF_BOX[crseBox],
     &      CHF_CONST_INT[edgeDir],
     &      CHF_CONST_INTVECT[refRatio],
     &      CHF_BOX[refBox])

      integer var
      integer CHF_AUTODECL[ic]
      integer CHF_AUTODECL[ip]
      integer CHF_AUTODECL[ii]
      REAL_T coarseSum, coarseECJSum

      do var = 0, CHF_NCOMP[coarse] - 1
        CHF_AUTOMULTIDO[crseBox;ic]
          CHF_DTERM[
          ip0 = ic0*refRatio(0);
          ip1 = ic1*refRatio(1);
          ip2 = ic2*refRatio(2)]

          coarseSum = zero
          coarseECJSum = zero

          ! loop over fine grid edges and compute sums
          CHF_AUTOMULTIDO[refBox;ii]
            coarseSum = coarseSum + fine(CHF_OFFSETIX[ip;+ii],var) * fineECJ(CHF_OFFSETIX[ip;+ii])
            coarseECJSum = coarseECJSum + fineECJ(CHF_OFFSETIX[ip;+ii])
          CHF_ENDDO

          coarse(CHF_AUTOIX[ic],var) = coarseSum / coarseECJSum
        CHF_ENDDO
      enddo


      return
      end
